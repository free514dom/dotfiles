既然你要**直接背诵的正文**，那我就不讲虚的了。

这里为你整理了一份**“高频必考”**的黄金八股文精简版。这份清单涵盖了 80% 的面试基础题。

**使用说明：** 看着加粗的关键词背，面试时把关键词串成句子讲出来。

---

### 第一章：Java 集合 (必背之王)

#### 1. ArrayList 和 LinkedList 的区别？
*   **底层数据结构：** `ArrayList` 底层是**动态数组**；`LinkedList` 底层是**双向链表**。
*   **查询性能：** `ArrayList` 支持随机访问，查询快（时间复杂度 O(1)）；`LinkedList` 需要遍历，查询慢（O(n)）。
*   **增删性能：** `ArrayList` 尾部增删快，中间增删慢（因为要移动数组元素）；`LinkedList` 增删快（只需修改指针），但查找位置慢。
*   **内存占用：** `LinkedList` 每个节点存两个指针，更占内存。

#### 2. HashMap 的底层原理（1.8 版本）？
*   **结构：** **数组 + 链表 + 红黑树**。
*   **Put 流程：**
    1.  计算 Key 的 `hash` 值，确定数组下标。
    2.  如果该位置为空，直接插入。
    3.  如果冲突（Hash 碰撞），判断 Key 是否相同，相同则覆盖 value。
    4.  不相同，放入链表或红黑树中。
*   **扩容机制：** 默认初始容量 **16**，加载因子 **0.75**。当 `size > 16 * 0.75` 时，扩容为原来的 **2倍**。
*   **红黑树转换：** 当链表长度 **> 8** 且数组长度 **> 64** 时，链表转为红黑树（提高查询效率从 O(n) 到 O(logn)）。

#### 3. HashMap 是线程安全的吗？怎么办？
*   **不安全：** 多线程下扩容可能会死循环（1.7）或数据覆盖（1.8）。
*   **解决：** 使用 **`ConcurrentHashMap`**。
*   **ConcurrentHashMap 原理 (1.8)：** 抛弃了 1.7 的分段锁（Segment），采用了 **`CAS + synchronized`** 来保证并发安全，锁粒度更细（锁住链表头节点），性能更高。

---

### 第二章：并发编程 (JUC)

#### 4. 线程的生命周期有哪些？
*   **新建 (New)**
*   **就绪 (Runnable)**
*   **运行 (Running)**
*   **阻塞 (Blocked)**：争抢锁失败。
*   **等待 (Waiting)**：`wait()` / `join()`。
*   **超时等待 (Timed_Waiting)**：`sleep(time)`。
*   **终止 (Terminated)**

#### 5. 线程池的 7 大参数（重点）？
1.  **`corePoolSize`**：核心线程数（常驻线程）。
2.  **`maximumPoolSize`**：最大线程数。
3.  **`keepAliveTime`**：空闲线程存活时间。
4.  **`unit`**：时间单位。
5.  **`workQueue`**：任务队列（核心线程满时，任务放这里）。
6.  **`threadFactory`**：线程工厂（用于创建线程，起名字）。
7.  **`handler`**：**拒绝策略**（队列满且线程达到最大时触发）。
    *   *拒绝策略有4种：* 抛异常(默认)、丢弃任务、丢弃最老任务、调用者自己执行。

#### 6. synchronized 和 ReentrantLock 的区别？
*   **层面：** `synchronized` 是 JVM 层面的**关键字**；`Lock` 是 API 层面的**类**。
*   **锁释放：** `synchronized` 执行完或异常**自动释放**；`Lock` 必须在 `finally` 中**手动释放** (`unlock()`)，否则死锁。
*   **功能：** `Lock` 功能更强大，支持**可中断**、**超时获取**、**公平锁**。

#### 7. volatile 的作用？
1.  **保证可见性：** 一个线程修改了变量，其他线程立马能看见（强制刷新回主内存）。
2.  **禁止指令重排：** 保证代码执行顺序（通过内存屏障）。
3.  *注意：volatile **不保证原子性**。*

---

### 第三章：JVM (虚拟机)

#### 8. JVM 内存区域划分？
*   **线程私有：**
    *   **程序计数器：** 记录代码执行到哪一行。
    *   **虚拟机栈：** 存局部变量、方法出口等（主要区域）。
    *   **本地方法栈：** Native 方法。
*   **线程共享：**
    *   **堆 (Heap)：** **对象实例**都在这分配，GC 的主要区域。
    *   **方法区 (MetaSpace)：** 类信息、常量、静态变量。

#### 9. 类加载机制（双亲委派）？
*   **流程：** 当一个类加载器收到加载请求，它自己不加载，而是**向上委托**给父类加载器，直到启动类加载器 (Bootstrap)。只有父类加载器无法加载时，子类才尝试自己加载。
*   **好处：** **安全**。防止核心 API 被篡改（比如你自己写个 `java.lang.String` 是不会被加载的）。

#### 10. 垃圾回收算法有哪些？
*   **标记-清除：** 产生内存碎片。
*   **标记-复制：** 浪费一半内存（新生代常用）。
*   **标记-整理：** 移动对象，无碎片（老年代常用）。
*   **分代收集：** 新生代用复制，老年代用整理。

---

### 第四章：MySQL 数据库

#### 11. 索引的数据结构？为什么用 B+ 树？
*   **结构：** **B+ 树**。
*   **原因：**
    1.  **层级低：** 树更矮胖，减少磁盘 IO 次数。
    2.  **范围查询快：** B+ 树叶子节点用**双向链表**连接，适合范围查询。
    3.  **全存叶子：** 非叶子节点只存索引，叶子节点存数据，单页能存更多索引。

#### 12. 聚簇索引和非聚簇索引的区别？
*   **聚簇索引：** 索引结构和数据**存放在一起**（主键索引就是聚簇索引）。找到索引就找到了数据。
*   **非聚簇索引（二级索引）：** 索引叶子节点存的是**主键 ID**。查询时需要**回表**（先查二级索引拿ID，再去聚簇索引查数据）。

#### 13. 事务的四大特性 (ACID)？
*   **A (Atomicity) 原子性：** 要么全成功，要么全失败（回滚）。
*   **C (Consistency) 一致性：** 守恒（转账前后总金额不变）。
*   **I (Isolation) 隔离性：** 事务之间互不干扰。
*   **D (Durability) 持久性：** 提交后永久保存。

#### 14. 事务隔离级别及解决的问题？
*   **读未提交：** 有脏读。
*   **读已提交 (RC)：** 解决脏读，有不可重复读。
*   **可重复读 (RR - MySQL默认)：** 解决不可重复读，**MVCC** 解决部分幻读。
*   **串行化：** 解决所有问题，但效率最低。

---

### 第五章：Redis 缓存

#### 15. Redis 的数据类型及应用场景？
1.  **String：** 缓存对象、计数器、分布式锁。
2.  **List：** 消息队列、粉丝列表。
3.  **Hash：** 购物车、存储对象详情。
4.  **Set：** 标签（Tag）、共同好友（交集）。
5.  **ZSet (Sorted Set)：** 排行榜。

#### 16. 缓存穿透、击穿、雪崩的区别及解决？
*   **缓存穿透：** 查**不存在**的数据（数据库也没，缓存也没），请求直打数据库。
    *   *解决：* 布隆过滤器、缓存空对象。
*   **缓存击穿：** **热点 Key** 过期的一瞬间，大量请求打库。
    *   *解决：* 互斥锁、逻辑过期（永不过期）。
*   **缓存雪崩：** **大量 Key 同时过期**或 Redis 宕机。
    *   *解决：* 过期时间加随机数、Redis 集群。

---

### 第六章：Spring 框架

#### 17. 什么是 IOC 和 AOP？
*   **IOC (控制反转)：** 把对象的创建和管理交给 Spring 容器，解耦。
*   **AOP (面向切面)：** 将**非业务逻辑**（日志、事务、权限）从业务代码中抽取出来，通过**动态代理**织入到目标方法中。

#### 18. Spring Bean 的生命周期？
**4 个关键步骤：**
1.  **实例化** (Instantiation)：分配内存空间。
2.  **属性赋值** (Populate)：依赖注入。
3.  **初始化** (Initialization)：执行初始化方法 (init-method, AOP 代理在这里生成)。
4.  **销毁** (Destruction)：容器关闭时。

#### 19. Spring 如何解决循环依赖？
*   通过 **三级缓存**。
*   **第一级：** 单例池（成品对象）。
*   **第二级：** 半成品池（实例化但未属性赋值）。
*   **第三级：** 工厂池（用于生成 AOP 代理对象）。
*   *核心逻辑：* A 依赖 B，B 依赖 A。A 实例化后放入三级缓存，去创建 B；B 发现依赖 A，直接从三级缓存拿 A 的引用（半成品），完成 B 的创建，再回头完成 A。

---

### 背诵建议

不要试图一次全部背下来。
**第一天：** 只背 **集合** 和 **MySQL**。
**第二天：** 只背 **并发** 和 **JVM**。
**第三天：** 只背 **Redis** 和 **Spring**。

先把这 19 题滚瓜烂熟，你就可以去面试了，能应付初中级大部分场面。加油！
